package main

//go:generate go build
//go:generate ./enums -i ../../wgpu/lib/wgpu.h -o ../../wgpu/enums.go -pkg wgpu

import (
	"bytes"
	"cmp"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"unicode"

	"slices"

	"github.com/iancoleman/strcase"
	"modernc.org/cc/v4"
	gofumpt "mvdan.cc/gofumpt/format"
)

var (
	inputFile   string
	outputFile  string
	packageName string
)

func init() {
	flag.StringVar(&inputFile, "i", "", "")
	flag.StringVar(&outputFile, "o", "", "")
	flag.StringVar(&packageName, "pkg", "", "")
}

type Pair struct {
	Enum  string
	Value int64
}

type TypedefEnum struct {
	Name  string
	Enums []Pair
}

type Enums []TypedefEnum

func (e Enums) Add(t string, enum string, value int64) Enums {
	found := false
	for i, v := range e {
		if v.Name == t {
			found = true
			v.Enums = append(v.Enums, Pair{
				Enum:  enum,
				Value: value,
			})
			e[i] = v
		}
	}

	if !found {
		e = append(e, TypedefEnum{
			Name: t,
			Enums: []Pair{{
				Enum:  enum,
				Value: value,
			}},
		})
	}
	return e
}

func main() {
	flag.Parse()

	in := mustv(os.ReadFile(inputFile))

	abi := mustv(cc.NewABI(runtime.GOOS, runtime.GOARCH))
	config := &cc.Config{
		ABI: abi,
	}

	sources := []cc.Source{
		{
			Name:  "defaults.h",
			Value: string(mustv(exec.Command("sh", "-c", "cc -dM -E - < /dev/null").Output())),
		},
		{
			Name:  filepath.Base(inputFile),
			Value: string(in),
		},
	}

	hostConfig, err := cc.NewConfig("", "")
	must(err)

	includePath := hostConfig.IncludePaths
	sysIncludePath := hostConfig.SysIncludePaths

	inputDir, err := filepath.Abs(filepath.Dir(inputFile))
	must(err)
	includePath = append(includePath, inputDir)
	includePath = append(includePath, sysIncludePath...)

	ast := mustv(cc.Translate(config, sources))
	var enums = Enums{}

	skipTypes := []string{
		"SType",
		"NativeSType",
	}

	mergeTypes := map[string]string{
		"NativeFeature": "FeatureName",
	}

	var flagTypes = map[string][]string{}

	for k := range ast.TLD {
		if !k.IsTypedefName || k.StorageClass != 1 {
			continue
		}

		if k.Type().String() != "WGPUFlags" {
			continue
		}

		flagTypes[k.Name().String()] = []string{}
	}

	fmt.Printf("flag types: %v\n", flagTypes)

	for k := range ast.TLD {
		t := k.Type().Name().String()

		if flagTypes[t] == nil { // Not a WGPUFlags type.
			continue
		}

		flagTypes[t] = append(flagTypes[t], k.Name().String())

		fmt.Printf("flag type: %s: %s = %#v\n", k.Name().String(), t, k.LHS())
	}

loop:
	for k, v := range ast.Enums {
		key := strings.TrimPrefix(k.String(), "WGPU")
		keyS := strings.Split(key, "_")
		typ := keyS[0]
		value := int64(v.Value().(cc.Int64Value))

		for _, v := range skipTypes {
			if typ == v {
				continue loop
			}
		}

		if strings.HasSuffix(key, "_Force32") {
			continue
		}

		inTyp, ok := mergeTypes[typ]
		key = strings.ReplaceAll(key, "_", "")
		if ok {
			enums = enums.Add(inTyp, key, value)
		} else {
			enums = enums.Add(typ, key, value)
		}
	}

	slices.SortStableFunc(enums, func(a, b TypedefEnum) int {
		return cmp.Compare(a.Name, b.Name)
	})

	w := &bytes.Buffer{}

	fmt.Fprintf(w, "// Code generated by github.com/cogentcore/webgpu/cmd/enums; DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package %s\n\n", packageName)

	for _, e := range enums {
		slices.SortStableFunc(e.Enums, func(a, b Pair) int {
			return cmp.Compare(a.Value, b.Value)
		})

		fmt.Fprintf(w, "type %s uint32\n\n", e.Name)
		for _, v := range e.Enums {
			enum := v.Enum
			value := v.Value
			fmt.Fprintf(w, "const %s %s = 0x%.8X\n", enum, e.Name, value)
		}

		fmt.Fprint(w, "\n")

		fmt.Fprintf(w, "func (v %s) String() string {\n", e.Name)
		fmt.Fprintf(w, "switch v {\n")
		for _, v := range e.Enums {
			fmt.Fprintf(w, "case %s:\n", v.Enum)
			// Kebab case is consistent with the enum values in JS.
			str := strcase.ToKebab(strings.TrimPrefix(v.Enum, e.Name))
			// Remove any hyphens connected to a digit, as JS does not include them.
			b := strings.Builder{}
			rs := []rune(str)
			for i, r := range rs {
				if r == '-' {
					if i > 0 && unicode.IsDigit(rs[i-1]) {
						continue
					}
					if i < len(rs)-1 && unicode.IsDigit(rs[i+1]) {
						continue
					}
				}
				b.WriteRune(r)
			}
			fmt.Fprintf(w, "return \"%s\"\n", b.String())
		}
		if e.Name == "ErrorType" {
			fmt.Fprintf(w, "default:\n")
			fmt.Fprintf(w, "return \"unknown\"\n")
		} else {
			fmt.Fprintf(w, "default:\n")
			fmt.Fprintf(w, "return \"\"\n")
		}
		fmt.Fprintf(w, "}\n")
		fmt.Fprintf(w, "}\n")
	}

	out := mustv(os.Create(outputFile))
	mustv(out.Write(fmtFile(w.Bytes())))
	must(out.Close())
}

func fmtFile(b []byte) []byte {
	langVersion := ""
	out, err := exec.Command("go", "list", "-m", "-f", "{{.GoVersion}}").Output()
	outSlice := bytes.Split(out, []byte("\n"))
	out = outSlice[0]
	out = bytes.TrimSpace(out)
	if err == nil && len(out) > 0 {
		langVersion = string(out)
	}

	// Run gofumpt
	b, err = gofumpt.Source(b, gofumpt.Options{LangVersion: langVersion, ExtraRules: true})
	if err != nil {
		log.Fatalf("cannot run gofumpt on file: %v", err)
	}

	return b
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

func mustv[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}
